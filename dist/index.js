module.exports=function(e,t){"use strict";var n={};function __webpack_require__(t){if(n[t]){return n[t].exports}var s=n[t]={i:t,l:false,exports:{}};e[t].call(s.exports,s,s.exports,__webpack_require__);s.l=true;return s.exports}__webpack_require__.ab=__dirname+"/";function startup(){return __webpack_require__(104)}return startup()}({58:function(e){e.exports=require("readline")},87:function(e){e.exports=require("os")},104:function(e,t,n){const s=n(413);const{analyzeCodeStatically:o,tool:{installGem:r}}=n(391);(async()=>{const e="brakeman";const t=["--no-progress","--no-exit-on-warn","-f","json","."];const n=(()=>{const e=[];return new s.Transform({readableObjectMode:true,transform:function(t,n,s){e.push(t);s()},flush:function(t){const n=JSON.parse(Buffer.concat(e).toString());console.log(`::debug::Detected ${n.warnings.length} problem(s).`);for(const e of n.warnings)this.push({file:e.file,line:e.line,column:0,severity:"warning",message:`[${e.confidence}] ${e.message}`,code:e.check_name});this.push(null);t()}})})();process.exitCode|=await o(e,t,undefined,[n],r(true,e))})().catch(e=>{console.log(`::error::${String(e)}`);process.exit(1)})},129:function(e){e.exports=require("child_process")},304:function(e){e.exports=require("string_decoder")},345:function(e,t,n){"use strict";var s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:true});const o=n(129);const r=s(n(747));const c=s(n(87));const i=s(n(622));const u=s(n(58));const a=s(n(413));const l=n(304);t.execute=((e,t=[],n={},s=1,r)=>{return new Promise((c,i)=>{let u;const a=o.spawn(e,t,n).once("error",i).once("exit",e=>u=e);a.stdout&&a.stdout.pipe(process.stdout);a.stderr&&a.stderr.pipe(process.stderr);const l=r?r(a):Promise.resolve(undefined);const f=async e=>e===null||e>=s?i(e):c(await l);if(u!==undefined)f(u);a.once("exit",f)})});t.stringify=(async e=>{const t=[];for await(const n of e)t.push(n);return Buffer.concat(t).toString().trim()});t.substitute=((e,n=[],s,r)=>new Promise((c,i)=>{const u=o.spawn(e,n,Object.assign({},s,{stdio:[r,"pipe","ignore"]})).once("error",i);if(u.stdout===null)return c("");t.stringify(u.stdout).then(c).catch(i)}));t.installGem=(async(e=true,...n)=>(async()=>{console.log(`::group::Installing gems...`)})().then(async()=>{return await Promise.all([(async()=>{const s=await(async(...t)=>{const n=new Map(t.map(e=>[e,undefined]));const s="Gemfile.lock";if(!r.default.existsSync(s))return n;const o=new RegExp(`^ {4}(${t.map(t=>e?t:t+"\\b[\\w-]*").join("|")}) \\((.*)\\)$`);for await(const e of u.default.createInterface(r.default.createReadStream(s))){const[t,s,r]=o.exec(e)||[];if(t)n.set(s,r)}return n})(...n);await(async(e,...n)=>{const s=["install"].concat(n);for(const[t,n]of e)s.push(`${t}${n&&":"+n||""}`);return t.execute("gem",s)})(s,"-N","--user-install");return s})(),(async()=>{const e=await t.substitute("gem",["environment","gempath"]);const n=(e?e.split(i.default.delimiter):[]).map(e=>i.default.join(e,"bin"));process.env["PATH"]=n.concat(process.env.PATH||"").join(i.default.delimiter)})()]).then(([e])=>e)}).finally(()=>console.log(`::endgroup::`)));class LineTransformStream extends a.default.Transform{constructor(e){super({writableObjectMode:true});this.decoder=new l.StringDecoder(e);this.buffer=""}_transform(e,t,n){try{const t=this.decoder.write(e);const s=(this.buffer+t).split(c.default.EOL);const o=s.pop();for(const e of s)this.push(e);this.buffer=o||"";n()}catch(e){n(e)}}_flush(e){try{const t=this.decoder.end();const n=(this.buffer+t).split(c.default.EOL);const s=n.pop();for(const e of n)this.push(e);if(s&&s.length)this.push(s);e()}catch(t){e(t)}}}t.LineTransformStream=LineTransformStream},357:function(e){e.exports=require("assert")},391:function(e,t,n){"use strict";var s=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};var o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(e!=null)for(var n in e)if(Object.hasOwnProperty.call(e,n))t[n]=e[n];t["default"]=e;return t};Object.defineProperty(t,"__esModule",{value:true});const r=n(357);const c=s(n(747));const i=s(n(87));const u=s(n(622));const a=s(n(58));const l=s(n(413));const f=o(n(345));t.tool=f;const d=async(e,t)=>{const n="git";const s=await f.execute(n,["remote","-v"],undefined,undefined,async e=>{r.strict(e.stdout!==null);if(e.stdout==null)return"";e.stdout.unpipe(process.stdout);const t=[];for await(const n of a.default.createInterface(e.stdout))if(/\bgithub\.com\b/.test(n)&&/ \(fetch\)$/.test(n))t.push(n);return t.map(e=>e.split("\t",1)[0])[0]});const o=await[e,t].map(e=>()=>f.execute(n,["rev-parse","--verify","-q",e],undefined,undefined,async e=>{r.strict(e.stdout!==null);if(e.stdout==null)return;e.stdout.unpipe(process.stdout);return f.stringify(e.stdout)}).catch(async()=>{await f.execute(n,["fetch","--depth=1","-q",s,e]);return f.execute(n,["rev-parse","--verify","-q",`${s}/${e}`],undefined,undefined,async e=>{r.strict(e.stdout!==null);if(e.stdout==null)return;e.stdout.unpipe(process.stdout);return f.stringify(e.stdout)})}).then(e=>(e||"").trim())).reduce((e,t)=>e.then(async e=>e.concat(await t())),Promise.resolve([]));const c=["--no-pager","diff","--no-prefix","--no-color","-U0","--diff-filter=b",o.join("...")];return f.execute(n,c,undefined,undefined,async e=>{const t=new Map;r.strict(e.stdout!==null);if(e.stdout==null)return t;e.stdout.unpipe(process.stdout);const n=[];for await(const t of a.default.createInterface(e.stdout))/^([@]{2}|[+]{3})\s/.test(t)&&n.push(t);let s="";for(const e of n){if(/^[+]{3}\s/.test(e)){s=e.substring("+++ ".length);continue}const n=((/^@@ (.*) @@.*$/.exec(e)||[])[1]||"").split(" ");const[o,r=1]=n[n.length-1].split(",").map(Number).map(Math.abs);t.set(s,(t.get(s)||[]).concat([[o,o+r-1]]))}return t})};t.analyzeCodeStatically=(async(e,t=[],n={},s=[],o=Promise.resolve(),a=1)=>{await o;console.log(`::group::Analyze code statically using ${e}`);return f.execute(e,t,n,a,e=>new Promise((t,n)=>{r.strict(e.stdout!==null);e.stdout&&e.stdout.unpipe(process.stdout);const[o=new l.default.PassThrough,a=o]=s.map(e=>e.once("error",n));e.stdout&&e.stdout.pipe(o);r.strict(process.env.GITHUB_BASE_REF,"Environment variable `GITHUB_BASE_REF` is undefined.");r.strict(process.env.GITHUB_HEAD_REF,"Environment variable `GITHUB_HEAD_REF` is undefined.");d(process.env.GITHUB_BASE_REF||"",process.env.GITHUB_HEAD_REF||"").then(e=>{a.pipe((()=>{const n={problemMatcher:[{owner:"analyze-result.tsv",pattern:[{regexp:"^\\[([^\\t]+)\\] Detected `([^\\t]+)` problem at line (\\d+), column (\\d+) of ([^\\t]+)\\t([^\\t]+)$",file:5,line:3,column:4,severity:1,message:6,code:2}]}]};let s=0;let o=false;return new l.default.Writable({objectMode:true,write:function(t,r,a){if(!o){const e=u.default.join(c.default.mkdtempSync(u.default.join(i.default.tmpdir(),`-`)),"problem-matcher.json");c.default.writeFileSync(e,JSON.stringify(n));console.log(`::add-matcher::${e}`);o=true}const l=u.default.relative(process.cwd(),t.file);const f=Number(t.line);const d=e.get(l)||[];for(const[e,n]of d)if(f>=e&&f<=n){const e=[t.severity,t.code,f,Number(t.column),l,t.message].map(e=>typeof e==="number"?e:(e===undefined?"":String(e)).replace(/\s+/g," "));console.log(`[%s] Detected \`%s\` problem at line %d, column %d of %s\t%s`,...e);s+=1;break}a()},final:function(e){console.log("::remove-matcher owner=analyze-result.tsv::");if(s>0){console.log(`Detected ${s} issue(s).`)}e();t(s>0?1:0)}})})()).once("error",n)})})).finally(()=>console.log(`::endgroup::`))})},413:function(e){e.exports=require("stream")},622:function(e){e.exports=require("path")},747:function(e){e.exports=require("fs")}});